{"config":{"indexing":"full","lang":["it"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Appunti universitari \u00b6 Questo sito/repo vuole essere un esperimento di studio, per capire se \u00e8 un'opzione fattibile prendere appunti in Markdown per i miei corsi di informatica. Al momento l'unica materia presente \u00e8 Fondamenti di Informatica , e appunto essendo un esperimento non vuole essere assolutamente una sorgente di materiali.","title":"Appunti universitari"},{"location":"#appunti-universitari","text":"Questo sito/repo vuole essere un esperimento di studio, per capire se \u00e8 un'opzione fattibile prendere appunti in Markdown per i miei corsi di informatica. Al momento l'unica materia presente \u00e8 Fondamenti di Informatica , e appunto essendo un esperimento non vuole essere assolutamente una sorgente di materiali.","title":"Appunti universitari"},{"location":"AnalisiI/","text":"","title":"Analisi I"},{"location":"FdI/","text":"","title":"Fondamenti di Informatica"},{"location":"FdI/calcoloCombinatorio/","text":"","title":"Calcolo Combinatorio"},{"location":"FdI/cheatsheet/","text":"Relazione Descrizione Totale Per ogni elemento in A, c'\u00e8 una connessione con almeno un elemento in B Univalente Per ogni elemento in A, c'\u00e8 al massimo una connessione (0 o 1) con un elemento in B Surgettiva Per ogni elemento in B, c'\u00e8 una connessione con almeno un elemento in A Iniettiva Per ogni elemento in B, c'\u00e8 al massimo una connessione (0 o 1) con un elemento in A Biietiva Tutte le precedenti Riflessiva Ogni elemento \u00e8 in relazione con s\u00e9 stesso (ha un cappio) (l'identit\u00e0 \u00e8 contenuta nella relazione) Transitiva Se esiste una relazione (a,b), e (b,c), esiste anche una relazione (a,c) Include anche la relazione vuota Antisimmetrica Non c'\u00e8 mai una relazione che va da a a b e contemporaneamente da b ad a (Non ci sono mai frecce opposte) \u00c8 tollerato lo stesso elemento (cappio) Simmetrica Per ogni relazione (a,b) , esiste una relazione (b,a) Per ogni elemento, ci sono 2 archi, uno da ed uno verso un altro elemento Composizione 2 relazioni sono composte quando l'elemento di arrivo per la prima diventa l'elemento di partenza per la seconda Avendo (a,b) e (b,c) in R, R composto R ( R;R ) \u00e8 ((a,b),c) , ovvero (a,c) R*, chiusura di Kleene La composizione di una relazione con s\u00e9 stessa infinite volte (zero incluso) \u00c8 riflessiva e transitiva Contiene l'identit\u00e0 (R0) R+, chiusura positiva R* ma senza 0 incluso Chiusura riflessiva Data una relazione R ed un insieme A, \u00e8 l'unione dell'identit\u00e0 di A con la relazione R Chiusura simmetrica Data una relazione R, \u00e8 l'unione di R ed R opposto Chiusura transitiva Data una relazione R, si unisce a questa la chiusura positiva fino a far diventare la funzione transitiva Ordinamento parziale Una relazione Riflessiva, Transitiva ed Antisimmetrica Ordinamento totale Ordinamento parziale + ogni (a, b) appartenente al prodotto cartesiano; (a,b) o (b,a) appartiene ad R Ogni coppia di elementi appartiene alla relazione R: ogni elemento \u00e8 in relazione con ogni altro elemento; C'\u00e8 una freccia per ogni elemento su ogni elemento Se \u00e8 totale, non \u00e8 parziale Grafo Relazione Descrizione Walk/Cammino Un collegamento da un nodo di partenza ad uno di arrivo Trail Un collegamento da un nodo di partenza ad uno di arrivo MA senza passare 2 volte per lo stesso arco (o collegamento) Path Un collegamento da un nodo di partenza ad uno di arrivo MA senza passare 2 volte per lo stesso NODO (o pallino/elemento) Non si deve passare 2 volte per lo stesso elemento Walk chiuso Un walk che permette di partire da un nodo e ritornare allo stesso ed ha lunghezza maggiore di 0 Circuito \u00c8 un walk chiuso che \u00e8 anche un trail (non si passa per lo stesso arco 2 volte) Ciclo \u00c8 un circuito che \u00e8 anche un path (non si passa per lo stesso nodo 2 volte) Aciclico Quando il grafo NON presenta un ciclo Connesso Quando ogni nodo \u00e8 \"raggiunto\" da almeno un arco (se \u00e8 orientato: sia in uscita che in entrata) Fortemente connesso Da ogni nodo, esiste un walk verso ogni altro nodo Componenti fortemente connesse Sottografi fortemente connessi (notare che ogni nodo pu\u00f2 arrivare a s\u00e9 stesso, quindi ogni nodo preso singolarmente \u00e8 una componente fortemente connessa) Universale Quando un nodo \u00e8 vicino a tutti gli altri DAG Grafo Aciclico Orientato Induzione (pecch\u00e9 non bastava prima)","title":"Cheatsheet"},{"location":"FdI/grafi/","text":"","title":"Grafi"},{"location":"FdI/induzione/","text":"","title":"Induzione Matematica"},{"location":"FdI/induzioneRicorsione/","text":"L'induzione strutturale \u00b6 L'induzione strutturale ci permette di: Definire in maniera induttiva delle strutture (dati) Definire induttivamente delle funzioni sulle strutture Dimostrare delle propriet\u00e0 sulle strutture dati usando il principio di Induzione Il tutto in maniera generale ed usando una struttura chiamata termini , definiti parametricamente su una segnatura . Definizione di Segnatura Una segnatura \u00e8 una famiglia di insiemi indicizzata da \\(\\mathbb{N}\\) ( \\(\\mathcal{F} = \\{\\mathcal{F}_n\\}_{n \\in \\mathbb{N} }\\) ) i cui elementi di ogni famiglia sono detti simboli . Questi elementi ci permettono di elencare e descrivere i simboli di un linguaggio formale. \\(\\mathcal{F}_n\\) \u00e8 l insieme dei simboli di ariet\u00e0 n (o con n argomenti). I simboli di ariet\u00e0 0 sono detti simboli di costante . Si pu\u00f2 pensare ai simboli \\(\\mathcal{F}\\) come funzioni, la cui arit\u00e0 definisce il numero di argomenti che le funzioni in quella famiglia prenderanno in input. In base al numero di argomenti, le funzioni possono assumere diversi nomi: Ariet\u00e0 Simboli 0 Constanti 1 Unari 2 Binari k k-arai Esempio di segnatura Prendiamo in considerazione la segnatura \\(\\mathcal{F}\\) : $$ \\mathcal{F}_0 = \\{ a, b \\} \\qquad \\mathcal{F}_1 = \\{ f \\} \\qquad \\mathcal{F}_2 = \\{ g \\} \\qquad \\mathcal{F}_n = \\varnothing ~ per ~ ogni ~ n ~ \\geq 3 $$ Quindi \\(a\\) e \\(b\\) sono termini costanti, \\(f\\) \u00e8 un termine unario e \\(g\\) \u00e8 un termine binario. Definizione di Termine Data una segnatura \\(\\mathcal{F}\\) , l'insieme \\(\\mathcal{F}Term\\) degli \\(\\mathcal{F}\\) -termini \u00e8 il pi\u00f9 piccolo insieme che soddisfa: Per ogni simbolo \\(c \\in \\mathcal{F}_0, c \\in \\mathcal{F}Term\\) (Ogni simbolo costante \u00e8 un (F-)termine) Per ogni \\(n \\geq 1\\) ed ogni simbolo \\(f \\in \\mathcal{F}_n\\) se \\(t_1,...,t_n \\in \\mathcal{F}Term\\) allora \\(f(t_1,...,t_n) \\in \\mathcal{F}Term\\) (Per ogni segnatura in ogni famiglia, se la segnatura \u00e8 chiamata con un numero di argomenti pari alla sua arit\u00e0, la segnatura \u00e8 un (F-)termine) Esempio di termini Continuando con l'esempio riportato sopra, \\(\\mathcal{F}\\) : $$ \\mathcal{F}_0 = \\{ a, b \\} \\qquad \\mathcal{F}_1 = \\{ f \\} \\qquad \\mathcal{F}_2 = \\{ g \\} \\qquad \\mathcal{F}_n = \\varnothing ~ per ~ ogni ~ n ~ \\geq 3 $$ Essendo \\(a\\) e \\(b\\) termini costanti, sono termini di F. Essendo \\(f\\) un termine unario, scritture come $$ f(a)\\qquad f(b)\\qquad f(f(a))\\qquad f(f(b))\\qquad f(f(f(f(b))))\\qquad $$ sono termini di F. Essendo \\(g\\) un termine binario, scritture come $$ g(a,b)\\qquad g(b,a)\\qquad g(f(a), b)\\qquad g(f(f(b)),a)\\qquad $$ sono termini di F. Non sono invece termini scritture come le seguenti: $$ f(a,b)\\qquad g(a) \\qquad g(a,a,b) \\qquad g \\qquad f \\qquad f(b,b,b,b,b) $$ Rappresentazione grafica dei termini \u00b6 \u00c8 inoltre possibile rappresentare i termini in maniera grafica sottoforma di alberi radicati. Ogni nodo dell'albero avr\u00e0 un'etichetta con un simbolo in \\(\\mathcal{F}\\) . Alberi \u00b6 TODO Rappresentazione di alberi binari come termini \u00b6 Gli alberi binari possono essere rappresentati la seguente segnatura \\(\\mathcal{BT}\\) : $$ \\mathcal{BT}_0 = \\{\\lambda\\} \\qquad \\mathcal{BT}_1 = \\varnothing \\qquad \\mathcal{BT}_2 = \\{N\\} \\qquad \\mathcal{BT}_n = \\varnothing ~ per ~ ogni ~ n ~ \\geq 3 $$ Liste \u00b6 TODO Rappresentazione di liste come termini \u00b6 Le liste possono essere rappresentate utilizzando la seguente segnatura \\(\\mathcal{L}^A\\) : $$ \\mathcal{L}^A_0 = \\{[ ~ ]\\} \\qquad \\mathcal{L}^A_1 = \\{a: ~ | ~ a \\in A\\} \\qquad \\mathcal{L}^A_n = \\varnothing ~ per ~ ogni ~ n ~ \\geq 2 $$ Che avr\u00e0 quindi come unica costante la segnatura \\([ ~ ]\\) ed un operatore unario \\(a :\\) per ogni \\(a \\in A\\) Naturali \u00b6 Anche i Naturali possono essere rappresentati come termini, con la seguente segnatura: $$ \\mathcal{N}_0 = \\{Z\\} \\qquad \\mathcal{N}_1 = \\{S\\} \\qquad \\mathcal{N}_n = \\varnothing ~ per ~ ogni ~ n ~ \\geq 2 $$ Funzioni su termini \u00b6 \u00c8 possibile definire delle funzioni (fin'ora definite induttivamente) in maniera pi\u00f9 generale facendo uso dei termini. Definire una funzione su \\(\\mathcal FTerm\\) (insieme dei termini per una segnatura \\(\\mathcal F\\) ) \u00e8 possibile in 2 passi: Definire il valore della funzione per i simboli di ariet\u00e0 0 (le costanti). Definire il valore della funzione per ogni simbolo di ariet\u00e0 \\(n \\geq 1\\) . Ricordare \u00e8 che possibile usare il valore appena calcolato per ogniuno degli altri n-valori. Valutazione di \\(\\mathcal N\\) -Termini La funzione \\(val: \\mathcal NTerm \\rightarrow \\mathbb N\\) pu\u00f2 essere definita induttivamente seguendo le propriet\u00e0 appena descritte: \\(val(Z) = 0\\) \\(val(S(x)) = val(x) + 1\\) Che con l'esempio \\(val(S(S(S(Z))))\\) pu\u00f2 essere sviluppata in questo modo: \\(val(S(S(S(Z))))=\\) \\(val(S(S(Z))) + 1=\\) (clausola induttiva) \\(val(S(Z)) + 1 + 1=\\) (clausola induttiva) \\(val(Z) + 1 + 1 + 1=\\) (clausola induttiva) \\(0 + 1 + 1 + 1=\\) (clausola base) \\(3\\) Somma di \\(\\mathcal N\\) -Termini La funzione \\(add: \\mathcal NTerm X \\mathcal NTerm \\rightarrow \\mathbb N\\) pu\u00f2 essere definita induttivamente seguendo le propriet\u00e0 appena descritte: \\(add(x, Z) = x\\) \\(add(x, S(y)) = S(add(x,y))\\) Che con l'esempio \\(add(S(S(S(Z))), S(S(Z)))\\) pu\u00f2 essere sviluppata in questo modo: \\(add(S(S(S(Z))), S(S(Z)))=\\) \\(S(add(S(S(S(Z))), S(Z))=\\) (clausola induttiva) \\(S(S(add(S(S(S(Z))), Z)))=\\) (clausola induttiva) \\(S(S(S(S(S(Z)))))=\\) (clausola base) Il principio di Induzione Strutturale \u00b6 Il Principio di Induzione Strutturale viene anche chiamato Principio di Induzione sui termini e stabilisce che: Principio di Induzione Strutturale (Caso base) Se per ogni simbolo \\(c \\in \\mathcal F_0, P(c)\\) \u00e8 vera (la propriet\u00e0 \\(P\\) \u00e8 vera per ogni simbolo costante) (Passo induttivo) Se per ogni \\(n \\geq 1\\) , per ogni simbolo \\(f \\in \\mathcal F_n\\) , per tutti i termini \\(t_1,...,t_n \\in \\mathcal FTerm\\) , vale che se \\(P(t_1),...,P(t_n)\\) sono vere, allora anche \\(P(f(t_1,...,t_n))\\) \u00e8 vera (per ogni simbolo non costante di arit\u00e0 N, se \\(P\\) vale per tutti gli N argomenti F-Termini, allora \\(P\\) vale anche per il simbolo) allora \\(P(t)\\) \u00e8 vera per ogni \\(t \\in \\mathcal FTerm\\) Ma non l'ho gi\u00e0 detto? Trascrivere a p. 7-21 esempio di val(add(x,y)) = val(x) + val(y)?? Molto povera questa sezione, da capire bene Funzioni ricorsive \u00b6 Le funzioni definite induttivamente sono un caso particolare di funzioni ricorsive. Definizione ricorsiva Una funzione \u00e8 detta ricorsiva se il valore della funzione per un certo argomento \u00e8 espresso in termini del valore della stessa funzione applcata a uno o pi\u00f9 argomenti, non necessariamente pi\u00f9 piccoli Il numero di passi per la risoluzione di una funzione non sempre segue una regola precisa. Inoltre non sempre una funzione ricorsiva risulta calcolabile: Il Teorema di Rice (facente parte del Teorema della Calcolabilit\u00e0 ) afferma che ~non esiste un procedimento universale~ che permtta di determinare con esattezza se una funzione recursiva \u00e8 totale (e quindi \u00e8 una funzione; in caso contrario sarebbe una funzione parziale ) \u00c8 possibile per\u00f2 individuare delle condizioni sufficienti che ci permettano di garantire che una definizione ricorsiva sia ben data (o ben definita). Ci interessa che la funzione ricorsiva sia totale perch\u00e9 se cos\u00ec non fosse, implicherebbe che valutando tale funzione incorreremmo in una computazione infinita. Tipologie di ricorsione \u00b6 Esistono vari tipi di ricorsione, oltre alla tipologia vista fin'ora, chiamata Ricorsione diretta Ricorsione annidata \u00b6 Questo tipo di ricorsione si ha quando una funzione ricorsiva richiama, nel proprio corpo, s\u00e9 stessa E s\u00e9 stessa come parametro, chiamando la funzione 2 volte Esempio di ricosione annidata Ricorsione mutua \u00b6 Ricorsione procedurale \u00b6","title":"Induzione Strutturale e Ricorsione"},{"location":"FdI/induzioneRicorsione/#linduzione-strutturale","text":"L'induzione strutturale ci permette di: Definire in maniera induttiva delle strutture (dati) Definire induttivamente delle funzioni sulle strutture Dimostrare delle propriet\u00e0 sulle strutture dati usando il principio di Induzione Il tutto in maniera generale ed usando una struttura chiamata termini , definiti parametricamente su una segnatura . Definizione di Segnatura Una segnatura \u00e8 una famiglia di insiemi indicizzata da \\(\\mathbb{N}\\) ( \\(\\mathcal{F} = \\{\\mathcal{F}_n\\}_{n \\in \\mathbb{N} }\\) ) i cui elementi di ogni famiglia sono detti simboli . Questi elementi ci permettono di elencare e descrivere i simboli di un linguaggio formale. \\(\\mathcal{F}_n\\) \u00e8 l insieme dei simboli di ariet\u00e0 n (o con n argomenti). I simboli di ariet\u00e0 0 sono detti simboli di costante . Si pu\u00f2 pensare ai simboli \\(\\mathcal{F}\\) come funzioni, la cui arit\u00e0 definisce il numero di argomenti che le funzioni in quella famiglia prenderanno in input. In base al numero di argomenti, le funzioni possono assumere diversi nomi: Ariet\u00e0 Simboli 0 Constanti 1 Unari 2 Binari k k-arai Esempio di segnatura Prendiamo in considerazione la segnatura \\(\\mathcal{F}\\) : $$ \\mathcal{F}_0 = \\{ a, b \\} \\qquad \\mathcal{F}_1 = \\{ f \\} \\qquad \\mathcal{F}_2 = \\{ g \\} \\qquad \\mathcal{F}_n = \\varnothing ~ per ~ ogni ~ n ~ \\geq 3 $$ Quindi \\(a\\) e \\(b\\) sono termini costanti, \\(f\\) \u00e8 un termine unario e \\(g\\) \u00e8 un termine binario. Definizione di Termine Data una segnatura \\(\\mathcal{F}\\) , l'insieme \\(\\mathcal{F}Term\\) degli \\(\\mathcal{F}\\) -termini \u00e8 il pi\u00f9 piccolo insieme che soddisfa: Per ogni simbolo \\(c \\in \\mathcal{F}_0, c \\in \\mathcal{F}Term\\) (Ogni simbolo costante \u00e8 un (F-)termine) Per ogni \\(n \\geq 1\\) ed ogni simbolo \\(f \\in \\mathcal{F}_n\\) se \\(t_1,...,t_n \\in \\mathcal{F}Term\\) allora \\(f(t_1,...,t_n) \\in \\mathcal{F}Term\\) (Per ogni segnatura in ogni famiglia, se la segnatura \u00e8 chiamata con un numero di argomenti pari alla sua arit\u00e0, la segnatura \u00e8 un (F-)termine) Esempio di termini Continuando con l'esempio riportato sopra, \\(\\mathcal{F}\\) : $$ \\mathcal{F}_0 = \\{ a, b \\} \\qquad \\mathcal{F}_1 = \\{ f \\} \\qquad \\mathcal{F}_2 = \\{ g \\} \\qquad \\mathcal{F}_n = \\varnothing ~ per ~ ogni ~ n ~ \\geq 3 $$ Essendo \\(a\\) e \\(b\\) termini costanti, sono termini di F. Essendo \\(f\\) un termine unario, scritture come $$ f(a)\\qquad f(b)\\qquad f(f(a))\\qquad f(f(b))\\qquad f(f(f(f(b))))\\qquad $$ sono termini di F. Essendo \\(g\\) un termine binario, scritture come $$ g(a,b)\\qquad g(b,a)\\qquad g(f(a), b)\\qquad g(f(f(b)),a)\\qquad $$ sono termini di F. Non sono invece termini scritture come le seguenti: $$ f(a,b)\\qquad g(a) \\qquad g(a,a,b) \\qquad g \\qquad f \\qquad f(b,b,b,b,b) $$","title":"L'induzione strutturale"},{"location":"FdI/induzioneRicorsione/#rappresentazione-grafica-dei-termini","text":"\u00c8 inoltre possibile rappresentare i termini in maniera grafica sottoforma di alberi radicati. Ogni nodo dell'albero avr\u00e0 un'etichetta con un simbolo in \\(\\mathcal{F}\\) .","title":"Rappresentazione grafica dei termini"},{"location":"FdI/induzioneRicorsione/#alberi","text":"TODO","title":"Alberi"},{"location":"FdI/induzioneRicorsione/#rappresentazione-di-alberi-binari-come-termini","text":"Gli alberi binari possono essere rappresentati la seguente segnatura \\(\\mathcal{BT}\\) : $$ \\mathcal{BT}_0 = \\{\\lambda\\} \\qquad \\mathcal{BT}_1 = \\varnothing \\qquad \\mathcal{BT}_2 = \\{N\\} \\qquad \\mathcal{BT}_n = \\varnothing ~ per ~ ogni ~ n ~ \\geq 3 $$","title":"Rappresentazione di alberi binari come termini"},{"location":"FdI/induzioneRicorsione/#liste","text":"TODO","title":"Liste"},{"location":"FdI/induzioneRicorsione/#rappresentazione-di-liste-come-termini","text":"Le liste possono essere rappresentate utilizzando la seguente segnatura \\(\\mathcal{L}^A\\) : $$ \\mathcal{L}^A_0 = \\{[ ~ ]\\} \\qquad \\mathcal{L}^A_1 = \\{a: ~ | ~ a \\in A\\} \\qquad \\mathcal{L}^A_n = \\varnothing ~ per ~ ogni ~ n ~ \\geq 2 $$ Che avr\u00e0 quindi come unica costante la segnatura \\([ ~ ]\\) ed un operatore unario \\(a :\\) per ogni \\(a \\in A\\)","title":"Rappresentazione di liste come termini"},{"location":"FdI/induzioneRicorsione/#naturali","text":"Anche i Naturali possono essere rappresentati come termini, con la seguente segnatura: $$ \\mathcal{N}_0 = \\{Z\\} \\qquad \\mathcal{N}_1 = \\{S\\} \\qquad \\mathcal{N}_n = \\varnothing ~ per ~ ogni ~ n ~ \\geq 2 $$","title":"Naturali"},{"location":"FdI/induzioneRicorsione/#funzioni-su-termini","text":"\u00c8 possibile definire delle funzioni (fin'ora definite induttivamente) in maniera pi\u00f9 generale facendo uso dei termini. Definire una funzione su \\(\\mathcal FTerm\\) (insieme dei termini per una segnatura \\(\\mathcal F\\) ) \u00e8 possibile in 2 passi: Definire il valore della funzione per i simboli di ariet\u00e0 0 (le costanti). Definire il valore della funzione per ogni simbolo di ariet\u00e0 \\(n \\geq 1\\) . Ricordare \u00e8 che possibile usare il valore appena calcolato per ogniuno degli altri n-valori. Valutazione di \\(\\mathcal N\\) -Termini La funzione \\(val: \\mathcal NTerm \\rightarrow \\mathbb N\\) pu\u00f2 essere definita induttivamente seguendo le propriet\u00e0 appena descritte: \\(val(Z) = 0\\) \\(val(S(x)) = val(x) + 1\\) Che con l'esempio \\(val(S(S(S(Z))))\\) pu\u00f2 essere sviluppata in questo modo: \\(val(S(S(S(Z))))=\\) \\(val(S(S(Z))) + 1=\\) (clausola induttiva) \\(val(S(Z)) + 1 + 1=\\) (clausola induttiva) \\(val(Z) + 1 + 1 + 1=\\) (clausola induttiva) \\(0 + 1 + 1 + 1=\\) (clausola base) \\(3\\) Somma di \\(\\mathcal N\\) -Termini La funzione \\(add: \\mathcal NTerm X \\mathcal NTerm \\rightarrow \\mathbb N\\) pu\u00f2 essere definita induttivamente seguendo le propriet\u00e0 appena descritte: \\(add(x, Z) = x\\) \\(add(x, S(y)) = S(add(x,y))\\) Che con l'esempio \\(add(S(S(S(Z))), S(S(Z)))\\) pu\u00f2 essere sviluppata in questo modo: \\(add(S(S(S(Z))), S(S(Z)))=\\) \\(S(add(S(S(S(Z))), S(Z))=\\) (clausola induttiva) \\(S(S(add(S(S(S(Z))), Z)))=\\) (clausola induttiva) \\(S(S(S(S(S(Z)))))=\\) (clausola base)","title":"Funzioni su termini"},{"location":"FdI/induzioneRicorsione/#il-principio-di-induzione-strutturale","text":"Il Principio di Induzione Strutturale viene anche chiamato Principio di Induzione sui termini e stabilisce che: Principio di Induzione Strutturale (Caso base) Se per ogni simbolo \\(c \\in \\mathcal F_0, P(c)\\) \u00e8 vera (la propriet\u00e0 \\(P\\) \u00e8 vera per ogni simbolo costante) (Passo induttivo) Se per ogni \\(n \\geq 1\\) , per ogni simbolo \\(f \\in \\mathcal F_n\\) , per tutti i termini \\(t_1,...,t_n \\in \\mathcal FTerm\\) , vale che se \\(P(t_1),...,P(t_n)\\) sono vere, allora anche \\(P(f(t_1,...,t_n))\\) \u00e8 vera (per ogni simbolo non costante di arit\u00e0 N, se \\(P\\) vale per tutti gli N argomenti F-Termini, allora \\(P\\) vale anche per il simbolo) allora \\(P(t)\\) \u00e8 vera per ogni \\(t \\in \\mathcal FTerm\\) Ma non l'ho gi\u00e0 detto? Trascrivere a p. 7-21 esempio di val(add(x,y)) = val(x) + val(y)?? Molto povera questa sezione, da capire bene","title":"Il principio di Induzione Strutturale"},{"location":"FdI/induzioneRicorsione/#funzioni-ricorsive","text":"Le funzioni definite induttivamente sono un caso particolare di funzioni ricorsive. Definizione ricorsiva Una funzione \u00e8 detta ricorsiva se il valore della funzione per un certo argomento \u00e8 espresso in termini del valore della stessa funzione applcata a uno o pi\u00f9 argomenti, non necessariamente pi\u00f9 piccoli Il numero di passi per la risoluzione di una funzione non sempre segue una regola precisa. Inoltre non sempre una funzione ricorsiva risulta calcolabile: Il Teorema di Rice (facente parte del Teorema della Calcolabilit\u00e0 ) afferma che ~non esiste un procedimento universale~ che permtta di determinare con esattezza se una funzione recursiva \u00e8 totale (e quindi \u00e8 una funzione; in caso contrario sarebbe una funzione parziale ) \u00c8 possibile per\u00f2 individuare delle condizioni sufficienti che ci permettano di garantire che una definizione ricorsiva sia ben data (o ben definita). Ci interessa che la funzione ricorsiva sia totale perch\u00e9 se cos\u00ec non fosse, implicherebbe che valutando tale funzione incorreremmo in una computazione infinita.","title":"Funzioni ricorsive"},{"location":"FdI/induzioneRicorsione/#tipologie-di-ricorsione","text":"Esistono vari tipi di ricorsione, oltre alla tipologia vista fin'ora, chiamata Ricorsione diretta","title":"Tipologie di ricorsione"},{"location":"FdI/induzioneRicorsione/#ricorsione-annidata","text":"Questo tipo di ricorsione si ha quando una funzione ricorsiva richiama, nel proprio corpo, s\u00e9 stessa E s\u00e9 stessa come parametro, chiamando la funzione 2 volte Esempio di ricosione annidata","title":"Ricorsione annidata"},{"location":"FdI/induzioneRicorsione/#ricorsione-mutua","text":"","title":"Ricorsione mutua"},{"location":"FdI/induzioneRicorsione/#ricorsione-procedurale","text":"","title":"Ricorsione procedurale"},{"location":"FdI/insiemi/","text":"Gli insiemi \u00b6 Definizione di insieme Un insieme \u00e8 una collezione di oggetti, chiamati elementi . Dato un oggetto a ed un insieme A, scriviamo \\(a \\in A\\) per dire che \\(a\\) \u00e8 un elemento di \\(A\\) . Ugualmente, scriviamo \\(a \\notin A\\) per dire che \\(a\\) non \u00e8 un elemento di \\(A\\) . Il simbolo \\(\\in\\) \u00e8 il simbolo di appartenenza Per gli insiemi valgono questi concetti: L'ordine in cui sono presentati gli elementi non \u00e8 rilevante Il numero di ripetizioni con cui sono presentati gli oggetti non \u00e8 rilevante Gli insiemi sono usati per raggruppare oggetti Definizione di insiemi \u00b6 Gli insiemi possono definire in diversi modi. Vale la pena specificare che spesso gli insiemi sono spesso definiti con lettere maiuscole, mentre gli elementi con lettere minuscole. Definzione per Enumerazione \u00b6 L'enumerazione (o modo estensionale ) consiste nell'elencare tutti gli elementi dell'insieme, separati da virgole. Esempio \\(Bool = {t,f}\\) Puntini Per quanto riguarda insiemi molto grandi, si possono usare i puntini ( \\(...\\) ) per sottointendere una regola di enumerazione. Notare che questa notazione \u00e8 informale ! L'insieme vuoto \u00b6 L'insieme vuoto \u00e8 l'insieme che non contiene nessun elemento ed \u00e8 rappresentato con il simbolo \\(\\varnothing\\) . L'insieme vuoto \\(\\varnothing = \\{\\}\\) Definizione per Propriet\u00e0 \u00b6 \u00c8 possibile descrivere un insieme anche mediante una propriet\u00e0 che tutti i suoi elementi soddisfano (anche conosciuto come modo intensionale ). Per farne uso indichiamo con \\(P\\) una generica propriet\u00e0 e con \\(P(a)\\) indichiamo che l'elemento \\(a\\) soddisfa la propriet\u00e0 \\(P\\) . In questo caso stiamo assumento che per ogni elemento \\(a\\) , questo o soddisfa la propriet\u00e0, o no. Definizione per propriet\u00e0 \\(X = \\{ x | x \\in A \\land P(x) \\}\\) In questo caso l'operatore \\(\\land\\) indica un \"e\", mentre il simbolo \\(|\\) si legge \"tale che\" e serve a specificare una condizione. L'equazione descritta si pu\u00f2 poi semplificare: \\(X = \\{ x \\in A | P(x) \\}\\) E se \\(A\\) \u00e8 implicito nel contesto: \\(X = \\{ x | P(x)\\}\\) I paradossi \u00b6 In base alle definizioni date, si possono verificare dei paradossi. Il paradosso di Russel \u00b6 Il paradosso di Russel \u00e8 un' antinomia (ovvero proposizione che risulta autocontraddittoria sia nel caso che sia vera, sia nel caso che sia falsa). Il segue questo tipo di ragionamento: Esistono insiemi che possono contenere loro stessi (ad esempio il numero di insiemi non vuoti \u00e8 contenuto: \\(X = \\{ x | x \\in x \\}\\) ) Esistono insiemi in cui essi stessi non risultano (ad esempio insiemi che contengono un solo elemento: \\(X = \\{ x \\space | \\space |x| = 1 \\}\\) ) Se definiamo \\(R\\) come l'insieme che non appartengono a s\u00e9 stessi, otteniamo \\(R = \\{ x | x \\notin x\\}\\) . A questo punto: Se l'affermazione \u00e8 vera : \\(R\\) appartiene a s\u00e9 stesso \\(R\\) soddisfa la definizione \\(R\\) \u00e8 un insieme che appartiene a s\u00e9 stesso \\(R\\) non pu\u00f2 appartenere a s\u00e9 stesso, che va contro il primo enunciato Se invece la consideriamo falsa: \\(R\\) non appartiene a s\u00e9 stesso \\(R\\) non soddisfa la definizione \\(R\\) non appartenendo a s\u00e9 stesso dovrebbe essere incluso nell'insieme \\(R\\) appartiene a s\u00e9 stesso, che va contro il primo enunciato I confronti tra insiemi \u00b6 Uguaglianza \u00b6 Uguaglianza tra insiemi Due insiemi sono uguali \\(A = B\\) , se hanno gli stessi elementi. Due insiemi sono diversi \\(A \\neq B\\) se hanno elementi diversi (uno dei 2 contiene almeno un elemento che non appartiene all'altro). Ricordando quindi la definizione, se due insiemi differiscono solo nella ripetizione e l'ordine degli elementi ( \\(A = \\{1,2\\}\\) , \\(B = \\{2, 1, 2, 2\\}\\) ), sono lo stesso insieme ( \\(A = B\\) ). Inclusione \u00b6 Inclusione tra insiemi \\(A\\) \u00e8 sottoinsime di \\(B\\) ( \\(A \\subseteq B\\) ) se ogni elemento di \\(A\\) \u00e8 anche elemento di \\(B\\) . \\(A\\) \u00e8 sottinsieme proprio di \\(B\\) ( \\(A \\subset B\\) ) se \\(A \\subseteq B \\land A \\neq B\\) . Due insiemi sono disgiunti se non hanno elementi in comune. Quindi: Per mostrare che \\(A \\subseteq B\\) , basta mostrare che ogni elemento di \\(A\\) appartiene a \\(B\\) . Per mostrare che \\(A = B\\) , basta mostrare che ogni elemento dell'uno appartiene all'altro, quindi \\(A \\subseteq B \\land B \\subseteq A\\) . Per mostrare che \\(A \\neq B\\) , basta esibire un elemento di un elemento che non appartiene all'altro. Per dismotrare che \\(A \\subset B\\) , con \\(A \\subseteq B\\) basta mostrare che un elemento di \\(B\\) che non appartiene ad \\(A\\) . Per dimostrare che i due insiemi sono disgiunti basta mostare che per ogni elemento di \\(A\\) non c'\u00e8 un elemento contenuto in \\(B\\) . Continuare da Pag. 1-5","title":"Insiemi"},{"location":"FdI/insiemi/#gli-insiemi","text":"Definizione di insieme Un insieme \u00e8 una collezione di oggetti, chiamati elementi . Dato un oggetto a ed un insieme A, scriviamo \\(a \\in A\\) per dire che \\(a\\) \u00e8 un elemento di \\(A\\) . Ugualmente, scriviamo \\(a \\notin A\\) per dire che \\(a\\) non \u00e8 un elemento di \\(A\\) . Il simbolo \\(\\in\\) \u00e8 il simbolo di appartenenza Per gli insiemi valgono questi concetti: L'ordine in cui sono presentati gli elementi non \u00e8 rilevante Il numero di ripetizioni con cui sono presentati gli oggetti non \u00e8 rilevante Gli insiemi sono usati per raggruppare oggetti","title":"Gli insiemi"},{"location":"FdI/insiemi/#definizione-di-insiemi","text":"Gli insiemi possono definire in diversi modi. Vale la pena specificare che spesso gli insiemi sono spesso definiti con lettere maiuscole, mentre gli elementi con lettere minuscole.","title":"Definizione di insiemi"},{"location":"FdI/insiemi/#definzione-per-enumerazione","text":"L'enumerazione (o modo estensionale ) consiste nell'elencare tutti gli elementi dell'insieme, separati da virgole. Esempio \\(Bool = {t,f}\\) Puntini Per quanto riguarda insiemi molto grandi, si possono usare i puntini ( \\(...\\) ) per sottointendere una regola di enumerazione. Notare che questa notazione \u00e8 informale !","title":"Definzione per Enumerazione"},{"location":"FdI/insiemi/#linsieme-vuoto","text":"L'insieme vuoto \u00e8 l'insieme che non contiene nessun elemento ed \u00e8 rappresentato con il simbolo \\(\\varnothing\\) . L'insieme vuoto \\(\\varnothing = \\{\\}\\)","title":"L'insieme vuoto"},{"location":"FdI/insiemi/#definizione-per-proprieta","text":"\u00c8 possibile descrivere un insieme anche mediante una propriet\u00e0 che tutti i suoi elementi soddisfano (anche conosciuto come modo intensionale ). Per farne uso indichiamo con \\(P\\) una generica propriet\u00e0 e con \\(P(a)\\) indichiamo che l'elemento \\(a\\) soddisfa la propriet\u00e0 \\(P\\) . In questo caso stiamo assumento che per ogni elemento \\(a\\) , questo o soddisfa la propriet\u00e0, o no. Definizione per propriet\u00e0 \\(X = \\{ x | x \\in A \\land P(x) \\}\\) In questo caso l'operatore \\(\\land\\) indica un \"e\", mentre il simbolo \\(|\\) si legge \"tale che\" e serve a specificare una condizione. L'equazione descritta si pu\u00f2 poi semplificare: \\(X = \\{ x \\in A | P(x) \\}\\) E se \\(A\\) \u00e8 implicito nel contesto: \\(X = \\{ x | P(x)\\}\\)","title":"Definizione per Propriet\u00e0"},{"location":"FdI/insiemi/#i-paradossi","text":"In base alle definizioni date, si possono verificare dei paradossi.","title":"I paradossi"},{"location":"FdI/insiemi/#il-paradosso-di-russel","text":"Il paradosso di Russel \u00e8 un' antinomia (ovvero proposizione che risulta autocontraddittoria sia nel caso che sia vera, sia nel caso che sia falsa). Il segue questo tipo di ragionamento: Esistono insiemi che possono contenere loro stessi (ad esempio il numero di insiemi non vuoti \u00e8 contenuto: \\(X = \\{ x | x \\in x \\}\\) ) Esistono insiemi in cui essi stessi non risultano (ad esempio insiemi che contengono un solo elemento: \\(X = \\{ x \\space | \\space |x| = 1 \\}\\) ) Se definiamo \\(R\\) come l'insieme che non appartengono a s\u00e9 stessi, otteniamo \\(R = \\{ x | x \\notin x\\}\\) . A questo punto: Se l'affermazione \u00e8 vera : \\(R\\) appartiene a s\u00e9 stesso \\(R\\) soddisfa la definizione \\(R\\) \u00e8 un insieme che appartiene a s\u00e9 stesso \\(R\\) non pu\u00f2 appartenere a s\u00e9 stesso, che va contro il primo enunciato Se invece la consideriamo falsa: \\(R\\) non appartiene a s\u00e9 stesso \\(R\\) non soddisfa la definizione \\(R\\) non appartenendo a s\u00e9 stesso dovrebbe essere incluso nell'insieme \\(R\\) appartiene a s\u00e9 stesso, che va contro il primo enunciato","title":"Il paradosso di Russel"},{"location":"FdI/insiemi/#i-confronti-tra-insiemi","text":"","title":"I confronti tra insiemi"},{"location":"FdI/insiemi/#uguaglianza","text":"Uguaglianza tra insiemi Due insiemi sono uguali \\(A = B\\) , se hanno gli stessi elementi. Due insiemi sono diversi \\(A \\neq B\\) se hanno elementi diversi (uno dei 2 contiene almeno un elemento che non appartiene all'altro). Ricordando quindi la definizione, se due insiemi differiscono solo nella ripetizione e l'ordine degli elementi ( \\(A = \\{1,2\\}\\) , \\(B = \\{2, 1, 2, 2\\}\\) ), sono lo stesso insieme ( \\(A = B\\) ).","title":"Uguaglianza"},{"location":"FdI/insiemi/#inclusione","text":"Inclusione tra insiemi \\(A\\) \u00e8 sottoinsime di \\(B\\) ( \\(A \\subseteq B\\) ) se ogni elemento di \\(A\\) \u00e8 anche elemento di \\(B\\) . \\(A\\) \u00e8 sottinsieme proprio di \\(B\\) ( \\(A \\subset B\\) ) se \\(A \\subseteq B \\land A \\neq B\\) . Due insiemi sono disgiunti se non hanno elementi in comune. Quindi: Per mostrare che \\(A \\subseteq B\\) , basta mostrare che ogni elemento di \\(A\\) appartiene a \\(B\\) . Per mostrare che \\(A = B\\) , basta mostrare che ogni elemento dell'uno appartiene all'altro, quindi \\(A \\subseteq B \\land B \\subseteq A\\) . Per mostrare che \\(A \\neq B\\) , basta esibire un elemento di un elemento che non appartiene all'altro. Per dismotrare che \\(A \\subset B\\) , con \\(A \\subseteq B\\) basta mostrare che un elemento di \\(B\\) che non appartiene ad \\(A\\) . Per dimostrare che i due insiemi sono disgiunti basta mostare che per ogni elemento di \\(A\\) non c'\u00e8 un elemento contenuto in \\(B\\) . Continuare da Pag. 1-5","title":"Inclusione"},{"location":"FdI/linguaggi/","text":"","title":"Linguaggi Formali"},{"location":"FdI/logica/","text":"La logica \u00b6 La logica serve per, date certe premesse, verificare la validit\u00e0 di un certo enunciato. Facciamo uso della logica per stabilire precisamente il significato degli enunciati matematici, e quindi determinare le argomentazioni valide. Questo tipo di distinzione ci permette di capire se una dimostrazione \u00e8 corretta oppure no. Questo signifiva che la logica non ci permette di determinare delle validit\u00e0 assolute, ma solo in funzione delle premesse. Possiamo inoltre dimostrare degli enunciati basandoci sulle dimostrazioni logiche effettuate in precedenza, creando una sorta di \"struttura di dimostrazioni\". Questo genere di dimostrazioni si dicono conseguenze logiche delle premesse. Logiche classiche Chiamiamo Logiche classiche quelle logiche che trattano enunciati che possono essere solo o veri o falsi. (Ovvero, formalmente, enunciati che possono assumere uno e solo uno dei valori parte dell'insieme \\(Bool = \\{ \\textbf t, \\textbf f\\}\\) .) Abbiamo parlato di proposizioni o enunciati, quindi cerchiamo di capire meglio di cosa si tratta: definiamo proposizione un'affermazione (possibilmente non ambigua e contraddittoria). Definizione di Proposizione Una proposizione \u00e8 un enunciato dichiarativo (nel senso che dichiara qualcosa, anche in un linguaggio naturale (come l'italiano) ). Questa poposizione deve soddisfare due principi: - Principio del terzo escluso: O la proposizione \u00e8 vera, o \u00e8 falsa, non ci sono altre possbilit\u00e0. - Principio di non contraddoriet\u00e0: La proposizioe non pu\u00f2 essere contemporaneamente vera e falsa. \u00c8 possibile rappresentare astrattamente una proposizione semplice (come ad esempio ora sta piovendo ). Notare inoltre che le proposizioni si possono rappresentare astrattamente con le lettere maiuscole ( \\(A = \\text{le biciclette possono volare.}\\) ). Il calcolo proposizionale \u00b6 Il calcolo proposizionale (o logica proposizionale ) si trova alla base delle logiche classiche e fornisce un insieme di regole di sintassi e semantica (come scrivere e leggere le formule proposizionali) Composizione di proposizioni \u00b6 Pi\u00f9 proposizioni sepmplici possono essere combinate insieme per formare proposizioni pi\u00f9 complesse. Queste composizioni sono rese possibili grazie ai connettivi logici (come and , or e not ), che vengono considerati operatori algebrici . Sintassi del calcolo proposizionale \u00b6 Il calcolo proposizionale fa uso di una grammatica ben specifica, formata dai simboli proposizionali (i simboli in un insieme che contiene le nostre proposizioni) il cui risultato viene definito formula proposizionale . Sintassi del calcolo proposizionale Preso un insieme di simboli proposizionali (che rappresentano proposizioni) \\(X = \\{A,B,C,..\\}\\) , il linguaggio (generato dalla categoria sintattica \\(\\langle Prop \\rangle\\) ) \u00e8 l'insieme delle formule proposizionali . Si tende ad indicare con i simboli A, B, C, ... i simboli proposizionali, mentre invece le lettere P, Q, R sono pi\u00f9 utilizzate per indicare le formule proposizionali. Grammatica del calcolo proposizionale \\(\\: \\langle Prop \\rangle \\leadsto \\langle Atom \\rangle | \\neg \\langle Atom \\rangle | \\langle Prop \\rangle \\langle OpB \\rangle \\langle Prop \\rangle\\) \\(\\langle Atom \\rangle \\leadsto \\textbf T | \\textbf F | \\langle X \\rangle | (\\langle Prop \\rangle)\\) - Questa regola ci permette di genere le formule atomiche \\(\\ \\langle OpB \\rangle \\leadsto \\land | \\lor | \\Rightarrow | \\Leftarrow | \\Leftrightarrow\\) - Questa regola ci permette di generare i connettivi logici \\(\\quad \\: \\langle X \\rangle \\leadsto A | B | C | \\dots\\) - Questa regola indica i simboli proposizionali I connettivi logici \u00b6 Per quanto riguarda i connettivi logici sopra descritti, rappresentano i pi\u00f9 comuni e possiamo osservare il loro significato : Simbolo Nome Utilizzo Lettura \\(\\neg\\) Negazione \\(\\neg P\\) \"Non P\" \"Not P\" \"Non \u00e8 vero che P vale\" \\(\\land\\) Congiunzione \\(P \\land Q\\) \"P e Q\" \"P and Q\" \"P e anche Q\" \\(\\lor\\) Discongiunzione \\(P \\lor Q\\) \"P o Q\" \"P or Q\" \"P oppure Q\" \\(\\Rightarrow\\) Implicazione \\(P \\Rightarrow Q\\) \"se P allora Q\" \"P implica Q\" \"P solo se Q\" \"P \u00e8 condizione sufficiente per Q\" \\(\\Leftarrow\\) Conseguenza \\(P \\Leftarrow Q\\) \"P \u00e8 conseguenza di Q\" \"P se Q\" \"P if Q\" \"P \u00e8 condizione necessaria per Q\" \\(\\Leftrightarrow\\) Doppia implicazione \\(P \\Leftrightarrow Q\\) \"P sse Q\" \"P se e solo se Q\" \"P iff Q\" \"P \u00e8 condizione necessaria e sufficiente per Q\" Nel caso dell'implicazione, \\(P\\) assume il nome di premessa , mentre \\(Q\\) quello di conseguenza o conclusione . Vale inoltre la pena notare che \\(P \\Leftarrow Q\\) \u00e8 logicamente equivalente a \\(Q \\Rightarrow P\\) . La formalizzazione di proposizioni \u00b6 Per formalizzare si intende il processo di estrarre da una proposizione in linguaggio naturale una una formula di calcolo proposizionale che ha la stessa struttura logica Esempio di formalizzazione Avendo la frase \" Piove e fa freddo \", possiamo da questa proposizione estrarre due proposizioni elementari: \\(P=\\) \" Piove \" e \\(Fr=\\) \" fa freddo \". La proposizione risultante sar\u00e0 quindi \\(P \\land Fr\\) La semantica \u00b6 Concetto di Tautologia \u00b6 Definizione di Tautologia Una tautologia \u00e8 una formula proposizionale che risulta sempre vera per ogni interpretazione |= P Definizione di Contraddizione Formula proposizionale che \u00e8 sempre falsa in tutte le interpretazioni |= not P Definizione di Soddisfacibile Ha almeno un'interpretazione che la rende vera \u00c8 vera in almeno un'interpretazione Comprendono anche le tautologie per ogni rovesciato P Definizione di interpretazione ... Non tautologie compendono anche le contraddizioni Dimostrazioni per sostituzione di tautologie \u00b6 Rimpiazzamento \u00b6 Principio di sostituzione \u00b6 \u00b6 Logica dei predicati \u00b6","title":"Logica Matematica"},{"location":"FdI/logica/#la-logica","text":"La logica serve per, date certe premesse, verificare la validit\u00e0 di un certo enunciato. Facciamo uso della logica per stabilire precisamente il significato degli enunciati matematici, e quindi determinare le argomentazioni valide. Questo tipo di distinzione ci permette di capire se una dimostrazione \u00e8 corretta oppure no. Questo signifiva che la logica non ci permette di determinare delle validit\u00e0 assolute, ma solo in funzione delle premesse. Possiamo inoltre dimostrare degli enunciati basandoci sulle dimostrazioni logiche effettuate in precedenza, creando una sorta di \"struttura di dimostrazioni\". Questo genere di dimostrazioni si dicono conseguenze logiche delle premesse. Logiche classiche Chiamiamo Logiche classiche quelle logiche che trattano enunciati che possono essere solo o veri o falsi. (Ovvero, formalmente, enunciati che possono assumere uno e solo uno dei valori parte dell'insieme \\(Bool = \\{ \\textbf t, \\textbf f\\}\\) .) Abbiamo parlato di proposizioni o enunciati, quindi cerchiamo di capire meglio di cosa si tratta: definiamo proposizione un'affermazione (possibilmente non ambigua e contraddittoria). Definizione di Proposizione Una proposizione \u00e8 un enunciato dichiarativo (nel senso che dichiara qualcosa, anche in un linguaggio naturale (come l'italiano) ). Questa poposizione deve soddisfare due principi: - Principio del terzo escluso: O la proposizione \u00e8 vera, o \u00e8 falsa, non ci sono altre possbilit\u00e0. - Principio di non contraddoriet\u00e0: La proposizioe non pu\u00f2 essere contemporaneamente vera e falsa. \u00c8 possibile rappresentare astrattamente una proposizione semplice (come ad esempio ora sta piovendo ). Notare inoltre che le proposizioni si possono rappresentare astrattamente con le lettere maiuscole ( \\(A = \\text{le biciclette possono volare.}\\) ).","title":"La logica"},{"location":"FdI/logica/#il-calcolo-proposizionale","text":"Il calcolo proposizionale (o logica proposizionale ) si trova alla base delle logiche classiche e fornisce un insieme di regole di sintassi e semantica (come scrivere e leggere le formule proposizionali)","title":"Il calcolo proposizionale"},{"location":"FdI/logica/#composizione-di-proposizioni","text":"Pi\u00f9 proposizioni sepmplici possono essere combinate insieme per formare proposizioni pi\u00f9 complesse. Queste composizioni sono rese possibili grazie ai connettivi logici (come and , or e not ), che vengono considerati operatori algebrici .","title":"Composizione di proposizioni"},{"location":"FdI/logica/#sintassi-del-calcolo-proposizionale","text":"Il calcolo proposizionale fa uso di una grammatica ben specifica, formata dai simboli proposizionali (i simboli in un insieme che contiene le nostre proposizioni) il cui risultato viene definito formula proposizionale . Sintassi del calcolo proposizionale Preso un insieme di simboli proposizionali (che rappresentano proposizioni) \\(X = \\{A,B,C,..\\}\\) , il linguaggio (generato dalla categoria sintattica \\(\\langle Prop \\rangle\\) ) \u00e8 l'insieme delle formule proposizionali . Si tende ad indicare con i simboli A, B, C, ... i simboli proposizionali, mentre invece le lettere P, Q, R sono pi\u00f9 utilizzate per indicare le formule proposizionali. Grammatica del calcolo proposizionale \\(\\: \\langle Prop \\rangle \\leadsto \\langle Atom \\rangle | \\neg \\langle Atom \\rangle | \\langle Prop \\rangle \\langle OpB \\rangle \\langle Prop \\rangle\\) \\(\\langle Atom \\rangle \\leadsto \\textbf T | \\textbf F | \\langle X \\rangle | (\\langle Prop \\rangle)\\) - Questa regola ci permette di genere le formule atomiche \\(\\ \\langle OpB \\rangle \\leadsto \\land | \\lor | \\Rightarrow | \\Leftarrow | \\Leftrightarrow\\) - Questa regola ci permette di generare i connettivi logici \\(\\quad \\: \\langle X \\rangle \\leadsto A | B | C | \\dots\\) - Questa regola indica i simboli proposizionali","title":"Sintassi del calcolo proposizionale"},{"location":"FdI/logica/#i-connettivi-logici","text":"Per quanto riguarda i connettivi logici sopra descritti, rappresentano i pi\u00f9 comuni e possiamo osservare il loro significato : Simbolo Nome Utilizzo Lettura \\(\\neg\\) Negazione \\(\\neg P\\) \"Non P\" \"Not P\" \"Non \u00e8 vero che P vale\" \\(\\land\\) Congiunzione \\(P \\land Q\\) \"P e Q\" \"P and Q\" \"P e anche Q\" \\(\\lor\\) Discongiunzione \\(P \\lor Q\\) \"P o Q\" \"P or Q\" \"P oppure Q\" \\(\\Rightarrow\\) Implicazione \\(P \\Rightarrow Q\\) \"se P allora Q\" \"P implica Q\" \"P solo se Q\" \"P \u00e8 condizione sufficiente per Q\" \\(\\Leftarrow\\) Conseguenza \\(P \\Leftarrow Q\\) \"P \u00e8 conseguenza di Q\" \"P se Q\" \"P if Q\" \"P \u00e8 condizione necessaria per Q\" \\(\\Leftrightarrow\\) Doppia implicazione \\(P \\Leftrightarrow Q\\) \"P sse Q\" \"P se e solo se Q\" \"P iff Q\" \"P \u00e8 condizione necessaria e sufficiente per Q\" Nel caso dell'implicazione, \\(P\\) assume il nome di premessa , mentre \\(Q\\) quello di conseguenza o conclusione . Vale inoltre la pena notare che \\(P \\Leftarrow Q\\) \u00e8 logicamente equivalente a \\(Q \\Rightarrow P\\) .","title":"I connettivi logici"},{"location":"FdI/logica/#la-formalizzazione-di-proposizioni","text":"Per formalizzare si intende il processo di estrarre da una proposizione in linguaggio naturale una una formula di calcolo proposizionale che ha la stessa struttura logica Esempio di formalizzazione Avendo la frase \" Piove e fa freddo \", possiamo da questa proposizione estrarre due proposizioni elementari: \\(P=\\) \" Piove \" e \\(Fr=\\) \" fa freddo \". La proposizione risultante sar\u00e0 quindi \\(P \\land Fr\\)","title":"La formalizzazione di proposizioni"},{"location":"FdI/logica/#la-semantica","text":"","title":"La semantica"},{"location":"FdI/logica/#concetto-di-tautologia","text":"Definizione di Tautologia Una tautologia \u00e8 una formula proposizionale che risulta sempre vera per ogni interpretazione |= P Definizione di Contraddizione Formula proposizionale che \u00e8 sempre falsa in tutte le interpretazioni |= not P Definizione di Soddisfacibile Ha almeno un'interpretazione che la rende vera \u00c8 vera in almeno un'interpretazione Comprendono anche le tautologie per ogni rovesciato P Definizione di interpretazione ... Non tautologie compendono anche le contraddizioni","title":"Concetto di Tautologia"},{"location":"FdI/logica/#dimostrazioni-per-sostituzione-di-tautologie","text":"","title":"Dimostrazioni per sostituzione di tautologie"},{"location":"FdI/logica/#rimpiazzamento","text":"","title":"Rimpiazzamento"},{"location":"FdI/logica/#principio-di-sostituzione","text":"","title":"Principio di sostituzione"},{"location":"FdI/logica/#_1","text":"","title":""},{"location":"FdI/logica/#logica-dei-predicati","text":"","title":"Logica dei predicati"},{"location":"FdI/relazioni/","text":"","title":"Relazioni"},{"location":"FdI/relazioniInsiemi/","text":"","title":"Relazioni su insiemi"},{"location":"LabI/","text":"","title":"Laboratorio I"},{"location":"ProAlgo/","text":"Definizione di Algoritmo \u00b6 Definizione di Programma \u00b6 Composizione di un programma \u00b6 Sintassi \u00b6 Categorie sintattiche \u00b6 Dichiarazioni \u00b6 Comandi \u00b6 Espressioni \u00b6 Lessico \u00b6 Grammatica \u00b6 Semantica \u00b6 Scoping \u00b6 Questa roba non so dove vada Funzioni \u00b6 Parametri formali Passaggio per riferimento e per valore Record di attivazione \u00b6 Contiene: - Identit\u00e0 - Chiamante - A chi restituire - Corpo della funzione corrente Tipologia di linguaggi \u00b6 Linguaggio interpretato \u00b6 Linugaggio compilato \u00b6 Architettura di von-Neumann \u00b6 Ciclo fetch-execute \u00b6 valutazione di un algoritmo \u00b6 Analizzare un algoritmo significa predirre le risorse che l'algoritmo richieder\u00e0. Si opssono predirre risorse come la memoria, la larghezza di banda per la comunicazione o qualche altra risorsa prima, ma tendenzialmente si tende a calcolare il tempo di computazione. Per farlo \u00e8 necessario fare uso di un modello che rappresenta l'implementazione che andremo ad usare (e quindi un modello per le risorse che andremo ad utilizzare). Il tempo di esecuzione di un algoritmo su un dato input \u00e8 il numero di operazioni primitive (o passi) eseguiti. \u00c8 conveniente definire la nozione di passo per essere il pi\u00f9 astratta e distaccata dalla macchina possibile. Il caso peggiore del tempo di esecuzione di un algoritmo ci fornisce il numero massimo di tempo che l'algoritmo impiegher\u00e0 per un dato input. Ci\u00f2 fornisce la garanzia che l'algoritmo non impiegher\u00e0 mai pi\u00f9 tempo del caso peggiore. Nei casi particolari nei quali si \u00e8 interessati ai casi medi, \u00e8 necessario ricorrere a tecniche di analisi probabilistica: potrebbe infatti non essere scontato cosa costituisce l'input di un problema medio. \u00c8 possibile poi applicare uno strato di astrazione: l'ordine di crescita (o rapporto di crescita): da un polinomio, prendiamo solo il monomio di grado superiore, ignorando i restati monomi di ordine inferiore. Oltre questo, ignoriamo anche il coefficiente del monomio che prendiamo in considerazione, che non risulta essere troppo influente sulla rapporto di crescita per grandi input. Possiamo quindi comparare 2 algoritmi sulla base della loro efficienza. La recurisione e l'approccio divide-and-conquer \u00b6 Si basa su 3 concetti: Divide: dividere il problema in sottoproblemi che sono istanze pi\u00f9 piccole del problema base Conquer: Risolvere il sottoproblema Combine: Combinare le soluzioni dei sottoproblemi in maniera recursiva fino a generare una soluzione per il problema originale La recursione termina quando arriva 'alla fine della corsa' (ovvero non \u00e8 pi\u00f9 possibile dividere il problema in ulteriori sottoproblemi dello stesso tipo dei precedenti). Questo tipo di approccio \u00e8 spesso utilizzato da algoritmi ricorsivi Definizione di algoritmo recursivo Si dice algoritmo recursivo quell'algoritmo che come parte della sua soluzione, chiama s\u00e9 stesso recursivamente una o pi\u00f9 volte per risolvere un sottoproblema strettamente correlato. Analisi degli algoritmi divide-and-conquer \u00b6 Quando un algoritmo effettua una chiamata recursiva a s\u00e9 stesso, spesso \u00e8 possibile descrivere il suo tempo di esecuzione facendo uso di una equazione (o relazione) di ricorrenza, che descrive il tempo di esecuzione dell'algoritmo dato un problema di grandezza n. Ricorrenza La ricorrenza \u00e8 un'equazione o diseguaglianza che descrive una funzione in termini di s\u00e9 stessa ma su valori pi\u00f9 piccoli Per risolvere un'equazione di ricorrenza (ovvero trovare il \\(\\Theta\\) asintotico (che tende ad infinito) ), ci sono vari metodi: Il metod[o di sostituzione Il metodo di sostisuzione si basa sull'indovinare un limite, per poi fare uso dell'induzione matematica per dimostrarlo Con un albero di ricorrenza Un albero di ricorrenza ci permette di convertire il problema in una struttura ad albero, in cui ogni nodo rappresenta il costo che si ha ai vari livelli della ricorsione. Esistono quindi tecniche per sommare i vari limiti e risolvere quindi la relazione Il master theorem Il master theorem \u00e8 un teorema che ci permtte di risolvere velocemente equazioni della forma \\(aT(\\frac{n}{b}) + f(n)\\) , con \\(a \\geq 1\\) che rappresenta il numero di sottoproblemi e \\(b > 1\\) , che descrive la grandeza di ogni sottoproblema e \\(f(n)\\) che descrive il tempo necessario ad effettuare la combinazione dei sottoproblemi RISCRIVERE SEGUENDO GLI APPUNTI DEL PROF Classi di complessit\u00e0 \u00b6 se io ho la chiamata ricorsiva n/2 allora \u00e8 log in base 2 di n n/4 l'altezza \u00e8 log in base 4 di n il numero di chiamate ricorsive \u00e8 il numero di figli di ogni nodo","title":"Definizione di Algoritmo"},{"location":"ProAlgo/#definizione-di-algoritmo","text":"","title":"Definizione di Algoritmo"},{"location":"ProAlgo/#definizione-di-programma","text":"","title":"Definizione di Programma"},{"location":"ProAlgo/#composizione-di-un-programma","text":"","title":"Composizione di un programma"},{"location":"ProAlgo/#sintassi","text":"","title":"Sintassi"},{"location":"ProAlgo/#categorie-sintattiche","text":"","title":"Categorie sintattiche"},{"location":"ProAlgo/#dichiarazioni","text":"","title":"Dichiarazioni"},{"location":"ProAlgo/#comandi","text":"","title":"Comandi"},{"location":"ProAlgo/#espressioni","text":"","title":"Espressioni"},{"location":"ProAlgo/#lessico","text":"","title":"Lessico"},{"location":"ProAlgo/#grammatica","text":"","title":"Grammatica"},{"location":"ProAlgo/#semantica","text":"","title":"Semantica"},{"location":"ProAlgo/#scoping","text":"Questa roba non so dove vada","title":"Scoping"},{"location":"ProAlgo/#funzioni","text":"Parametri formali Passaggio per riferimento e per valore","title":"Funzioni"},{"location":"ProAlgo/#record-di-attivazione","text":"Contiene: - Identit\u00e0 - Chiamante - A chi restituire - Corpo della funzione corrente","title":"Record di attivazione"},{"location":"ProAlgo/#tipologia-di-linguaggi","text":"","title":"Tipologia di linguaggi"},{"location":"ProAlgo/#linguaggio-interpretato","text":"","title":"Linguaggio interpretato"},{"location":"ProAlgo/#linugaggio-compilato","text":"","title":"Linugaggio compilato"},{"location":"ProAlgo/#architettura-di-von-neumann","text":"","title":"Architettura di von-Neumann"},{"location":"ProAlgo/#ciclo-fetch-execute","text":"","title":"Ciclo fetch-execute"},{"location":"ProAlgo/#valutazione-di-un-algoritmo","text":"Analizzare un algoritmo significa predirre le risorse che l'algoritmo richieder\u00e0. Si opssono predirre risorse come la memoria, la larghezza di banda per la comunicazione o qualche altra risorsa prima, ma tendenzialmente si tende a calcolare il tempo di computazione. Per farlo \u00e8 necessario fare uso di un modello che rappresenta l'implementazione che andremo ad usare (e quindi un modello per le risorse che andremo ad utilizzare). Il tempo di esecuzione di un algoritmo su un dato input \u00e8 il numero di operazioni primitive (o passi) eseguiti. \u00c8 conveniente definire la nozione di passo per essere il pi\u00f9 astratta e distaccata dalla macchina possibile. Il caso peggiore del tempo di esecuzione di un algoritmo ci fornisce il numero massimo di tempo che l'algoritmo impiegher\u00e0 per un dato input. Ci\u00f2 fornisce la garanzia che l'algoritmo non impiegher\u00e0 mai pi\u00f9 tempo del caso peggiore. Nei casi particolari nei quali si \u00e8 interessati ai casi medi, \u00e8 necessario ricorrere a tecniche di analisi probabilistica: potrebbe infatti non essere scontato cosa costituisce l'input di un problema medio. \u00c8 possibile poi applicare uno strato di astrazione: l'ordine di crescita (o rapporto di crescita): da un polinomio, prendiamo solo il monomio di grado superiore, ignorando i restati monomi di ordine inferiore. Oltre questo, ignoriamo anche il coefficiente del monomio che prendiamo in considerazione, che non risulta essere troppo influente sulla rapporto di crescita per grandi input. Possiamo quindi comparare 2 algoritmi sulla base della loro efficienza.","title":"valutazione di un algoritmo"},{"location":"ProAlgo/#la-recurisione-e-lapproccio-divide-and-conquer","text":"Si basa su 3 concetti: Divide: dividere il problema in sottoproblemi che sono istanze pi\u00f9 piccole del problema base Conquer: Risolvere il sottoproblema Combine: Combinare le soluzioni dei sottoproblemi in maniera recursiva fino a generare una soluzione per il problema originale La recursione termina quando arriva 'alla fine della corsa' (ovvero non \u00e8 pi\u00f9 possibile dividere il problema in ulteriori sottoproblemi dello stesso tipo dei precedenti). Questo tipo di approccio \u00e8 spesso utilizzato da algoritmi ricorsivi Definizione di algoritmo recursivo Si dice algoritmo recursivo quell'algoritmo che come parte della sua soluzione, chiama s\u00e9 stesso recursivamente una o pi\u00f9 volte per risolvere un sottoproblema strettamente correlato.","title":"La recurisione e l'approccio divide-and-conquer"},{"location":"ProAlgo/#analisi-degli-algoritmi-divide-and-conquer","text":"Quando un algoritmo effettua una chiamata recursiva a s\u00e9 stesso, spesso \u00e8 possibile descrivere il suo tempo di esecuzione facendo uso di una equazione (o relazione) di ricorrenza, che descrive il tempo di esecuzione dell'algoritmo dato un problema di grandezza n. Ricorrenza La ricorrenza \u00e8 un'equazione o diseguaglianza che descrive una funzione in termini di s\u00e9 stessa ma su valori pi\u00f9 piccoli Per risolvere un'equazione di ricorrenza (ovvero trovare il \\(\\Theta\\) asintotico (che tende ad infinito) ), ci sono vari metodi: Il metod[o di sostituzione Il metodo di sostisuzione si basa sull'indovinare un limite, per poi fare uso dell'induzione matematica per dimostrarlo Con un albero di ricorrenza Un albero di ricorrenza ci permette di convertire il problema in una struttura ad albero, in cui ogni nodo rappresenta il costo che si ha ai vari livelli della ricorsione. Esistono quindi tecniche per sommare i vari limiti e risolvere quindi la relazione Il master theorem Il master theorem \u00e8 un teorema che ci permtte di risolvere velocemente equazioni della forma \\(aT(\\frac{n}{b}) + f(n)\\) , con \\(a \\geq 1\\) che rappresenta il numero di sottoproblemi e \\(b > 1\\) , che descrive la grandeza di ogni sottoproblema e \\(f(n)\\) che descrive il tempo necessario ad effettuare la combinazione dei sottoproblemi RISCRIVERE SEGUENDO GLI APPUNTI DEL PROF","title":"Analisi degli algoritmi divide-and-conquer"},{"location":"ProAlgo/#classi-di-complessita","text":"se io ho la chiamata ricorsiva n/2 allora \u00e8 log in base 2 di n n/4 l'altezza \u00e8 log in base 4 di n il numero di chiamate ricorsive \u00e8 il numero di figli di ogni nodo","title":"Classi di complessit\u00e0"},{"location":"ProAlgo/relazioniRicorrenza/","text":"Relazioni di ricorrenza \u00b6","title":"Relazioni di ricorrenza"},{"location":"ProAlgo/relazioniRicorrenza/#relazioni-di-ricorrenza","text":"","title":"Relazioni di ricorrenza"}]}